---
layout: post
title: Telegram CLI
category: Telegram CLI
tags:
- Telegram CLI
- CLI
---

Всем привет. На днях начал своё знакомство с консольным клиентом для `Telegram`. Решил по этому поводу написать пару статей.
Для начала расскажу, как это дело установить, в следующей части опишу, как запускать [**telegram-cli** в виде демона в системах с **systemd**]({{ site.basepath }} /telegram-cli-daemon/), а в качестве бонуса будет статья о том, [как написать обёртку]({{ site.basepath }} /telegram-cli-fun/) под всё это для zsh, и, моё любимое, автодополнение по tab'у.

## Установка
У меня стоит `Fedora 22` в репозиториях которой присутствует `telegram-cli`, поэтому если вы в таких же условиях, то можно сделать так:

~~~ bash
sudo dnf install telegram-cli
~~~

Но мы пойдём другим путём и установим его из сорцов, тем более что это делается очень просто.

## Сборка из исходников

> **Историческая справка**  
Раньше в UNIX системах директория `/opt` использовалась для пакетов сторонних производителей. opt это сокращение от option, что можно перевести как *опциональный* или *необязательный*; туда, например попадали пакеты, за которые вы заплатили деньги. В BSD Unix системах вместо `/opt` для этих целей использовали `/usr/local`.  
[via](https://stackoverflow.com/questions/12649355/what-does-opt-mean-as-in-the-opt-directory-is-it-an-abbreviation)

Я предпочитаю устанавливать сторонние программы в директорию `/opt`. Перейдём в неё и клонируем репозиторий

~~~ bash
sudo git clone --recursive https://github.com/vysheng/tg.git /opt/tg
cd /opt/tg
~~~

Дальше нужно установить зависимости. В исторукции из репозитория написано установить `libjansson-devel`, который моему dnf'у найти не удалось, зато он нашёл `jansson-devel`.

~~~ bash
sudo dnf install -y lua-devel openssl-devel libconfig-devel readline-devel libevent-devel jansson-devel python-devel
~~~

Мы уже находимся в каталоге `/opt/tg` поэтому начнем сборку.
~~~ bash
./configure
make
~~~

Если всё прошло хорошо, то в папке `bin` должен появиться `telegram-cli`. Осталось запихнуть его куда-нибудь в пути.
~~~ bash
ln -s /opt/tg/bin/telegram-cli /usr/bin/
~~~

Пробуем запустить

~~~ bash
telegram-cli
~~~
Получилось? Тогда учимся пользоваться.

## Запуск
Сначала `telegram-cli` спросит номер телефона. Вводим. Ждём сообщения с кодом. Вводим код. Получаем доступ к командной строке.


|Вид из командной строки                          | Пришедший код                                       |
|:-----------------------------------------------:|:---------------------------------------------------:|
|![]({{ site.baseurl }}/images/tcli/tcli-cli.png) | ![]({{ site.baseurl }}/images/tcli/tcli-code.png)   |

## Использование
Что первым делом нужно вводить в любую консоль?

~~~
help
~~~

Посмотрим, что у нас есть

### Доступные команды

Для начала сделаю лирическое отступление и расскажу, что такое `peer` и как его употреблять.
> **Из официальной документации**
Peer это имя контакта или диалога; можно дополнять по TAB'у. Все пробелы заменяются на нижние подчеркивания.  
Если у двух пользователей одинаковые имена, то к ним добавляется номер телефона. (например, Имя\_Фамилия будет Имя\_Фамилия#1, Имя_Фамилия#2 и так далее)

Чтобы появилась возможность отправлять сообщения, нужно сначала получить все диалоги с помощью `dialog_list`, либо запускать клиент с параметром `-W`. Рекомендую второе.

*peer я оставлю без перевода и буду писать пир*

#### Общение

* **msg** \<peer\> Text - отправить сообщение пиру
* **fwd** \<user\> \<msg-seqno\> - переслать сообщение пользователю. Вы можете видеть номера сообщений, запуская клиент с опцией -N
* **chat\_with_peer** \<peer\> - начать переписку с этим пиром. /exit или /quit для завершения этого режима.
* **add_contact** \<phone-number\> \<first-name\> \<last-name\> - попытаться добавить контакт в список контактов по номеру телефона
* **rename_contact** \<user\> \<first-name\> \<last-name\> - попытаться переименовать контакт. Если у вас есть несколько устройств, то будет битва
* **mark_read** \<peer\> - отметить прочитанными все сообщения от пира
* **delete_msg** \<msg-seqno\> - удалить сообщение (но не полностью)
* **restore_msg** \<msg-seqno\> - восстановить удалённое сообщение. Невозможно для серкретного чата. Возможно только некоторое время спустя (один час, я думаю) после удаления

#### Мультимедия

* **send_photo** \<peer\> \<photo-file-name\> - отправить фото
* **send_video** \<peer\> \<video-file-name\> - отправить видео
* **send_text** \<peer\> \<text-file-name> - отправить содержимое файла текстом
* **load\_photo/load\_video/load\_video\_thumb/load\_audio/load\_document/load\_document_thumb** \<msg-seqno\> - загрузить фото/видео/аудио/документ в директорию загрузок
* **view\_photo/view\_video/view\_video\_thumb/view\_audio/view\_document/view\_document_thumb** \<msg-seqno\> - загрузить фото/видео в папку загрузок и открыть стандартным просмоторщиком
* **fwd\_media** \<msg-seqno\> послать медиа файл в сообщении. Используйте это, чтобы скрыть информацию об авторе медиа файла (хотя всё ещё будет возможно найтиuser\_id из самого медиа файла, но невозможно получить access_hash этого пользователя)
* **set\_profile_photo** \<photo-file-name\> - установить фотографию профиля. Обрезается до квадрата


#### Групповые чаты

* **chat_info** \<chat\> - вывести информацию о чате
* **chat\_add_user** \<chat\> \<user\> - добавить пользователя в чат
* **chat\_del_user** \<chat\> \<user\> - удалить пользователя из чата
* **rename\_chat** \<chat\> \<new-name\>
* **create\_group\_chat** \<chat topic\> \<user1\> \<user2\> \<user3\> ... -  создать групповой чат с пользователями, используйте chat\_add_user чтобы добавить больше пользователей
* **chat\_set_photo** \<chat\> \<photo-file-name\> - поставить фото на чат. Обрезается до квадрата

#### Поиск

* **search** \<peer\> pattern - поиск pattern в сообщениях с пиром
* **global_search** pattern - поиск pattern во всех сообщениях

#### Секретный чат

* **create\_secret_chat** \<user\> - создать секретный чат с пользователем
* **visualize_key** \<secret_chat\> - вывести визуализацию ключа шифрования. Вы должны сравнить его с ключем вашего собеседника
* **set_ttl** \<secret_chat\> \<ttl\> - установить ttl в секретном чате. Не смотря на то, что клиент игнорирует это, вашему собеседнику это может быть полезно
* **accept\_secret_chat** \<secret_chat\> - вручную принять секретный чат (действенно только если клиент запущен с ключём -E)

#### Статистика и информация

* **user_info** \<user\> - вывести информацию о пользователе
* **history** \<peer\> [limit] - вывести историю (и пометить прочитаными). Лимит по умолчанию = 40
* **dialog_list** - вывести информацию о диалогах
* **contact_list** - вывести информацию о пользователях в вашем списке контактов
* **suggested_contacts** - вывести информацию о пользователях с которыми у вас много общих друзей
* **stats** - для отладки
* **show_license** - показать лицензию(GPLv2)
* **help** - вывести этот хэлп
* **get_self** - получить инфорцию о своем пользователе

#### Карточки
* **export_card** - вывести ваше 'карточку' которую каждый позже может импортировать себе в контакты
* **import_card** \<card\> - получить пользователя по карточке. После этого вы сможете писать ему сообщения

#### Остальное
* **quit** - выйти
* **safe_quit** - подождать завершения всех запросов и выйти

### Практика

Напишем сообщение Даниле и посмотрим, что он ответит. Отправить сообщение можно не сразу, сначала нужно дождаться, пока прогрузяться все контакты.

~~~ bash
telegram-cli -W
msg Данила ping
~~~

![]({{ site.baseurl }} /images/tcli/tcli-msg.png)

Готово! Вы восхетительны.  

В [следующей статье]( {{ site.basepath }} /telegram-cli-daemon/ ) мы рассмотрим, как сделать из этого добра systemd демона, чтобы не ждать каждый раз прогрузки контактов.
